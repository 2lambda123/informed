{"version":3,"file":"main.a6355f47137e4ab58f97.bundle.js","sources":["webpack:///./src/ObjectMap.js"],"sourcesContent":["import ldset from 'lodash/setWith';\nimport ldunset from 'lodash/unset';\nimport ldtoPath from 'lodash/toPath';\nimport ldget from 'lodash/get';\nimport ldhas from 'lodash/has';\nimport ldvalues from 'lodash/values';\nimport ldpullAt from 'lodash/pullAt';\nimport ldpull from 'lodash/pull';\nimport Debug from './debug';\nconst debug = Debug('informed:ObjMap' + '\\t');\n\nconst pathToArrayElem = (path) => {\n  const pathArray = ldtoPath(path);\n  return Number.isInteger(+pathArray[pathArray.length - 1]);\n};\n\nclass ObjectMap {\n  static empty(object) {\n    return ldvalues(object).length === 0;\n  }\n\n  static get(object, path) {\n    const val = ldget(object, path);\n    debug('GOT', path, val);\n    return val;\n  }\n\n  static has(object, path) {\n    return ldhas(object, path);\n  }\n\n  static set(object, path, value) {\n    if (value !== undefined) {\n      debug('SETTING', path, value);\n      ldset(object, path, value);\n    } else {\n      // Setting things to undefined in informed is special!\n      // so in this else statement we deal with that\n\n      // If the path is to an array leaf then we want to set to undefined\n      // Example: \n      // path = 'foo.bar[2]'\n      // foo.bar = [ 'baz', 'raz', 'taz' ]\n      // setting taz to undefined   ^^^\n      if (pathToArrayElem(path) && ObjectMap.get(object, path) !== undefined) {\n        debug('Special case SETTING', path, 'to undefined');\n        ldset(object, path, undefined);\n        let pathArray = ldtoPath(path);\n        pathArray = pathArray.slice(0, pathArray.length - 1);\n        cleanup(object, pathArray, false);\n      }\n      // Only delete the field if it needs to be deleted and its not a path to an array ( array leaf )\n      // Example: \n      // path = 'foo.bar'\n      // foo.bar = 'baz'\n      // removing foo.bar from the object completley\n      else if (!pathToArrayElem(path) && ObjectMap.get(object, path) !== undefined) {\n        debug('Special case REMOVING', path, 'from object completley');\n        ObjectMap.delete(object, path);\n      }\n    }\n  }\n\n  static delete(object, path) {\n    debug('DELETE', path);\n    ldunset(object, path);\n    let pathArray = ldtoPath(path);\n    pathArray = pathArray.slice(0, pathArray.length - 1);\n    cleanup(object, pathArray);\n  }\n\n  // May need to do this some day ;)\n  // static pullOut(object, path, index) {\n  //   // Get the path to the array\n  //   let pathArray = ldtoPath(path);\n  //   pathArray = pathArray.slice(0, pathArray.length - 1).join();\n  //   debug('PathArray', pathArray);\n  //   // Get the array\n  //   const arr = ldget(object, pathArray);\n  //   debug('Array', arr);\n  //   // Pull out of array\n  //   ldpullAt(arr, index);\n  // }\n}\n\nfunction cleanup(obj, path, pull = true) {\n  // Base case no path left\n  if (path.length === 0) {\n    return;\n  }\n\n  const object = ldget(obj, path);\n\n  // Clean up undefined from array\n  if (Array.isArray(object) && pull) {\n    ldpull(object, undefined);\n  }\n\n  // Delete object if its empty\n  if (\n    Array.isArray(object)\n      ? object.every(e => e == null)\n      : JSON.stringify(object) === '{}'\n  ) {\n    ldunset(obj, path);\n  }\n  // Recur\n  cleanup(obj, path.slice(0, path.length - 1));\n}\n\nexport default ObjectMap;\n"],"mappings":"AASA","sourceRoot":""}